SHELL = /bin/bash
LAMBDA_ROOT ?= .
MAKEFILE := $(lastword $(MAKEFILE_LIST))

SRC_FILES = $(LAMBDA_ROOT)/include/lambda.h $(wildcard $(LAMBDA_ROOT)/include/lambda/*.h)

ifeq ($(BIN),)
MAYBE_BIN := $(shell for f in `ls *.cc`; do b=`basename $$f .cc`; [ -e $$b.hs ] && echo $$b; done)
ifeq  ($(words $(MAYBE_BIN)),1)
BIN = $(MAYBE_BIN)
else
BIN = lambda
endif
endif

PLATFORM := $(shell uname)
ifeq ($(PLATFORM),Darwin)
GCC = $(shell which g++-mp-4.7 g++ | head -n 1)
SED = gsed
else
ifeq ($(shell hostname -s | grep '^soc1$$' > /dev/null && echo 1 || echo 0),1)
GCC = $(HOME)/local/usr/bin/g++
else
GCC = /usr/bin/g++
endif
SED = sed
endif

ifeq ($(shell hostname -s | grep '^[sn]oc[12]$$' > /dev/null && echo 1 || echo 0),1)
DOT = /opt/sw/graphviz/bin/dot
else
DOT = dot
endif

VALGRIND = valgrind --trace-children=yes
GDB = gdb

ifeq ($(PLATFORM),Darwin)
PERF = time
PERF_IS_TIME = 2
else
ifeq ($(shell which perf 2>/dev/null),)
PERF = /usr/bin/time -f '%Uuser %Ssystem %eelapsed %PCPU (%Xtext+%Ddata %Mmax)k'
PERF_IS_TIME = 1
else
PERF = perf stat
ifneq ($(BM_REPEAT),)
PERF += -r $(BM_REPEAT)
endif
PERF_IS_TIME = 0
endif
endif

ifeq ($(PROCS),)
ifeq ($(PLATFORM),Darwin)
PROCS := $(shell sysctl hw.ncpu | gawk '{print $$2}')
else
PROCS := $(shell grep '^processor\>' /proc/cpuinfo | wc -l)
endif
else
FORCE_REBUILD := 1
endif

ifneq ($(CFLAGS),)
FORCE_REBUILD := 1
endif

ifneq ($(FORCE_REBUILD),)
.PHONY: $(BIN) $(addprefix $(BIN)-,debug mf vg prf bm mb.elf mb-debug.elf)
endif

override CFLAGS += -I$(LAMBDA_ROOT)/include -Wall -Werror -Wnon-virtual-dtor -Woverloaded-virtual -DLAMBDA_WORKERS=$(PROCS)
CFLAGS_X86 = $(CFLAGS) -march=native -O3 -pthread -DLAMBDA_DOT_FILE=$(BIN).dot -DLAMBDA_VCD_PREFIX=$(BIN)
CFLAGS_MB = $(CFLAGS) -fno-exceptions
CFLAGS_SYM = $(CFLAGS_X86) -g -DLAMBDA_BACKTRACE

LDFLAGS =
ifeq ($(shell hostname -s | grep '^[sn]oc[12]$$' > /dev/null && echo 1 || echo 0),1)
CFLAGS_X86 += -I/opt/sw/gmp/include
LDFLAGS += -L/opt/sw/gmp/lib -Wl,-rpath=/opt/sw/gmp/lib
endif
ifneq ($(PLATFORM),Darwin)
CFLAGS_SYM += -rdynamic
LDFLAGS += -lrt
else
CFLAGS_X86 += -I/opt/local/include
LDFLAGS += -L/opt/local/lib -Wl,-rpath=/opt/local/lib
endif
LDFLAGS += -pthread -lm -lgmp

LDFLAGS_MB = -lgmp

ifeq ($(shell $(GCC) -dumpversion | $(SED) 's/^\([0-9]\+\.[0-9]\+\)\..*$$/\1/'),4.4)
CFLAGS_X86 += -Wno-strict-aliasing
endif

combine = $(foreach left,$(1),$(addprefix $(left),$(2)))
EMPTY = 

all: $(BIN)

test:
	# normal execution
	$(MAKE) BIN=$(BIN) PROCS=$(PROCS) debug-run
	$(MAKE) BIN=$(BIN) PROCS=$(PROCS) run
	[ ! -e $(BIN).dot ] || \
		$(MAKE) BIN=$(BIN) dot
	[ ! -e $(BIN)_w0.vcd ] || \
		$(MAKE) BIN=$(BIN) PROCS=$(PROCS) vcd
ifneq ($(PLATFORM),Darwin)
	# verification
	[ ! which valgrind >/dev/null 2>&1 ] || \
		$(MAKE) BIN=$(BIN) PROCS=$(PROCS) mem-run
	[ ! which valgrind >/dev/null 2>&1 ] || \
		$(MAKE) BIN=$(BIN) PROCS=$(PROCS) call-run
endif
	! echo 'int main(){}' | $(GCC) -xc -fmudflap -lmudflap -o /dev/null - >/dev/null 2>&1 || \
		$(MAKE) BIN=$(BIN) PROCS=$(PROCS) mudflap-run
	# performance (comparison)
	if [ -e $(BIN).hs ] && which ghc >/dev/null 2>&1; then \
		$(MAKE) BIN=$(BIN) PROCS=$(PROCS) compare; \
	else \
		$(MAKE) BIN=$(BIN) PROCS=$(PROCS) bm-run; \
	fi
ifneq ($(PLATFORM),Darwin)
	# MicroBlaze compiling test
	$(MAKE) BIN=$(BIN) PROCS=$(PROCS) mb mb-debug
endif

help:
	@echo 'Execution targets'
	@echo '  all          builds normal x86 $(BIN), MicroBlaze $(BIN)-mb and $(BIN)_hs (default target)'
	@echo '  run          runs $(BIN) with performance measurements'
	@echo '  debug-run    builds and runs $(BIN)-debug with all debugging options'
	@echo '  mb           builds $(BIN)-mb.nc for Starburst'
	@echo '  mb-debug     builds $(BIN)-mb-debug.nc for Starburst with all debugging options'
	@echo '  hs-run       builds and runs $(BIN)_hs, when $(BIN).hs exists'
	@echo ''
	@echo 'Analysis targets'
	@echo '  bm-run       builds, profiles, optimizes and runs $(BIN)-bm'
	@echo '  bm-sweep     does bm-run for 1 to $(PROCS) processors'
	@echo '  bm-analyze   analyzes $(BIN).log, as generated by bm-sweep'
	@echo '  vcd          generates $(BIN).vcd, based on last run of $(BIN) or $(BIN)-debug'
	@echo '  dot          generates $(BIN).ps, based on last run of $(BIN) or $(BIN)-debug'
	@echo ''
	@echo 'Verification targets'
	@echo '  gdb-run      starts $(BIN)-debug in gdb'
	@echo '  mudflap-run  builds and runs $(BIN)-mf for mudflap'
	@echo '  mem-run      builds and runs $(BIN)-vg for valgrand'
	@echo '  call-run     builds and runs $(BIN)-vg for callgrind'
	@echo '  test         runs a series of verification targets'
	@echo '  compare      runs bm-run and hs-run'
	@echo ''
	@echo 'Maintainance targets'
	@echo '  svn          sets svn:ignore on current directory'
	@echo '  clean        cleans all garbage'
	@echo ''
	@echo 'make variables'
	@echo '  BIN          use another program (default: detect .cc or use lambda.cc)'
	@echo '  PROCS        set processors/workers (default: all listed in /proc/cpuinfo)'
	@echo '  ARGS         list of arguments for all *-run targets (default: empty)'
	@echo '  PRF_ARGS     list of arguments for profiling and verification (default: same as ARGS)'

GARBAGE =


###########################################
## Running normally

$(BIN): $(BIN).cc $(SRC_FILES)
	$(GCC) $(CFLAGS_SYM) -o $@ $< $(LDFLAGS)

run: $(BIN)
	@echo "Normal run..."
	$(PERF) ./$< $(ARGS)

GARBAGE += $(BIN) $(BIN).dSYM


###########################################
## Running in high-performance benchmark mode

PRF_ARGS ?= $(ARGS)

.PHONY: $(BIN)-bm $(BIN)-prf
$(BIN)-prf: $(BIN).cc $(SRC_FILES)
	$(GCC) $(CFLAGS_X86) -DLAMBDA_BENCHMARK -fwhole-program -fprofile-generate -o $@ $< $(LDFLAGS)

prf-run $(BIN).gcda: $(BIN)-prf
	@echo "Generating profile for benchmark..."
	@[ ! -e $(BIN).gcda ] || rm $(BIN).gcda
	./$< $(PRF_ARGS) $(OUTPUT_FILTER) || ./$< $(PRF_ARGS) $(OUTPUT_FILTER)

$(BIN)-bm: $(BIN).cc $(SRC_FILES) $(BIN).gcda
	$(GCC) $(CFLAGS_X86) -DLAMBDA_BENCHMARK -fwhole-program -fprofile-correction -fprofile-use -o $@ $< $(LDFLAGS)

bm-run: $(BIN)-bm
	@echo "Benchmark run..."
	$(PERF) ./$< $(ARGS) $(OUTPUT_FILTER)

bm-sweep $(BIN).log:
	@echo "Benchmark sweep up to $(PROCS) cores..."
	@for (( p = 1 ; p <= $(PROCS) ; p++ )); do \
		echo "=== Benchmarking for $$p cores..."; \
		$(MAKE) BIN=$(BIN) PRF_ARGS="$(PRF_ARGS)" BM_REPEAT=5 ARGS="$(ARGS)" PROCS=$$p FORCE_REBUILD=1 bm-run || \
		{ echo "Execution failed, redo with debugging and abort..."; \
		  $(MAKE) BIN=$(BIN) ARGS="$(ARGS)" PROCS=$$p FORCE_REBUILD=1 debug-run run; \
		  exit 1; }; \
	done 2>&1 | tee $(BIN).log

BM_LOG ?= $(BIN).log
ifeq ($(PERF_IS_TIME),1)
bm-analyze: | $(BM_LOG)
	@cat $| | $(SED) 's/^[-0-9: ]\{19\}: //' | gawk ' \
		BEGIN{c=0;printf("cores,load,cycles,instructions,exec time\n")}			\
		/[^e]elapsed/{															\
			print																\
				(c+1)	","														\
				(gensub(/%CPU$$/,"","1",$$4)/100) "," 							\
				(-1) "," (-1) ","												\
				(gensub(/elapsed$$/,"","1",$$3));								\
			c++;																\
		}'
else
ifeq ($(PERF_IS_TIME),0)
bm-analyze: | $(BM_LOG)
	@cat $| | $(SED) 's/^[-0-9: ]\{19\}: //' | gawk '							\
		BEGIN{s=0;c=0;printf("cores,load,cycles,instructions,exec time,speedup,instr per cycle,norm speedup\n")}	\
		/^ Performance counter stats for.*/{s=1;c++;printf(c ",")}				\
		s==1&&/CPUs utilized/{printf($$4 ",");}									\
		s==1&&$$2~/^cycles/{cy=gensub(/,/,"","g",$$1);printf(cy ",");}			\
		s==1&&/instructions/{ins=gensub(/,/,"","g",$$1);printf(ins ",");}		\
		s==1&&/seconds time elapsed/{											\
			e=gensub(/,/,"","g",$$1);											\
			if(c==1){printf(e ",1,%f,1\n",ins/cy);first_e=e;first_ipc=ins/cy;}	\
				else printf(e ",%f,%f,%f\n",first_e/e,ins/cy,first_e/(e/(first_ipc/(ins/cy))));	\
			s=0}																\
	'
else
bm-analyze:
	@echo "Running on Mac, no analysis implemented"
endif
endif

GARBAGE += $(addprefix $(BIN),-prf -prf.dSYM -bm -bm.dSYM .gcda)


###########################################
## Running in debug mode

$(BIN)-debug: $(BIN).cc $(SRC_FILES)
	$(GCC) $(CFLAGS_SYM) -O0 -fstack-protector -fstack-check -DLAMBDA_DEBUG -o $@ $< $(LDFLAGS)

.gdbinit: $(MAKEFILE)
	@echo -e 'set pagination off\nhandle SIGUSR1 nostop\nhandle SIGUSR2 nostop\nhandle SIG34 nostop\nhandle SIGALRM nostop' > $@ 

gdb-run: $(BIN)-debug | .gdbinit
	@echo -e 'run $(ARGS)' > $(BIN).gdb
	$(GDB) -x $(BIN).gdb ./$<

debug-run: $(BIN)-debug
	@echo "Debug run..."
	./$< $(ARGS)

$(BIN)-mf: $(BIN).cc $(SRC_FILES)
	$(GCC) $(CFLAGS_SYM) -fmudflapth -O3 -DLAMBDA_MEMCHECK -o $@ $< $(LDFLAGS) -lmudflapth 

mudflap-run: $(BIN)-mf
	env MUDFLAP_OPTIONS="-collect-stats" ./$< $(PRF_ARGS)

GARBAGE += $(addprefix $(BIN),-debug -debug.dSYM -mf -mf.dSYM .gdb) .gdbinit


###########################################
## Checking with valgrind

HAVE_VALGRIND = $(shell echo -e '\#include <valgrind/valgrind.h>\nint main(){}' | $(GCC) -xc -o /dev/null - >/dev/null 2>&1 && echo '-DHAVE_VALGRIND')

$(BIN)-vg: $(BIN).cc $(SRC_FILES)
	$(GCC) $(CFLAGS_SYM) -O3 -DLAMBDA_MEMCHECK $(HAVE_VALGRIND) -o $@ $< $(LDFLAGS)

call-run: $(BIN)-vg
	$(VALGRIND) --vgdb=no --tool=callgrind --callgrind-out-file=$(BIN).call ./$< $(PRF_ARGS)

mem-run: $(BIN)-vg
	$(VALGRIND) --vgdb=no --leak-check=full ./$< $(PRF_ARGS)

gdb-mem-run: $(BIN)-vg
	$(VALGRIND) --vgdb=yes --vgdb-error=1 --leak-check=full --read-var-info=yes ./$< $(PRF_ARGS)

GARBAGE += $(addprefix $(BIN),-vg -vg.dSYM .call)


###########################################
## VCD output

vcd: $(BIN).vcd $(BIN).csv

$(BIN).vcd: $(wildcard $(shell for (( i = 0 ; i < $(PROCS); i++ )); do echo $(BIN)_w$$i.vcd; done))
	@echo "Generating $@..."
	@for f in $^; do gawk '/^#/{print NR " " gensub(/^#/,"","1",$$0);next}{print $$0}' $$f; done | \
	sort -n -k2,2 -k1,1 | \
	gawk ' \
		BEGIN{ \
			print "$$date '"`date`"' $$end"; \
			print "$$timescale 1 ms $$end"; \
			print "$$scope module $(BIN) $$end"; \
			print "$$var real 1 m mem_alloc_kb $$end"; \
			print "$$var real 1 p par_queue $$end"; \
		} \
		/^\$$/{print $$0;next} \
		s==0&&!/^\$$/{ \
			print "$$var string 1 s stdout $$end"; \
			print "$$upscope $$end"; \
			print "$$enddefinitions $$end"; \
			s=1; \
		} \
		{ \
			data = \
				gensub(/	/,"\\\\\\\\n","g", \
					gensub(/ +/,"\\\\\\\\x20","g", \
						gensub(/\\/,"\\\\\\\\x5c","g", \
							gensub(/^[0-9]+ [0-9]+ (.*)(.w[0-9]*| .)$$/,"\\1","1",$$0)))); \
			print gensub(/^[0-9]+ ([0-9]+) .*(.w[0-9]*| .)$$/,"#\\1\n" data "\\2","1",$$0);} \
	' > $@

$(BIN).csv: $(wildcard $(shell for (( i = 0 ; i < $(PROCS); i++ )); do echo $(BIN)_w$$i.vcd; done))
	@{ \
		echo "worker,running,idle,local_gc,global_gc,stalling,total";	\
		for f in $^; do											\
			gawk '												\
			BEGIN{prevtime=0;starttime=0;}						\
			/^\#[0-9]+ [-10zw]w[0-9]+$$/{						\
				time=gensub(/^\#/,"","1",$$1);					\
				if(prevtime==0){								\
					prevtime=starttime=time;					\
					worker=gensub(/^.w/,"","1",$$2);			\
				}else{											\
					if(prevtime==time&&phase=="w")time++;		\
					stats[phase]+=time-prevtime;				\
					prevtime=time;								\
				}												\
				phase=gensub(/^(.)w.*/,"\\1","1",$$2);			\
			}													\
			END{												\
				printf("%d,%d,%d,%d,%d,%d,%d\n",				\
					worker,										\
					stats["1"]+0,								\
					stats["0"]+0,								\
					stats["w"]+0,								\
					stats["-"]+0,								\
					stats["z"]+0,								\
					time-starttime);							\
			}													\
			' $$f;												\
		done | 													\
		gawk '													\
			BEGIN{FS=",";totals[0]="#total"}					\
			{print $$0;}										\
			/^[0-9]/{for(f=2;f<=NF;f++)totals[f]+=$$f;}			\
			END{												\
				printf("%s",totals[0]);							\
				for(f=2;f<=length(totals);f++)printf(FS "%d",totals[f]);	\
				printf("\n");									\
			}													\
		';														\
	} > $@

GARBAGE += $(addprefix $(BIN),.vcd _w*.vcd .csv)


###########################################
## Dot output

dot: $(BIN).dot
	$(DOT) -Tps -o$(BIN).ps $<

GARBAGE += $(addprefix $(BIN),.dot .ps)


###########################################
## MicroBlaze build
SOC_HOME ?= $(LAMBDA_ROOT)/../../starburst/trunk

ifneq ($(PLATFORM),Darwin)
HAVE_MB := $(shell [ -e "$(SOC_HOME)" ] && echo 1 || echo 0)
else
HAVE_MB = 0
endif

ifeq ($(HAVE_MB),1)

MB_GCC ?= $(shell which $(SOC_HOME)/bin/mb-g++ mb-g++ 2>/dev/null | head -n 1)
ifeq ($(MB_GCC),)
MB_GCC = mb-g++
endif

ifneq ($(ARGS),)
.PHONY: $(BIN)-mb.elf $(BIN)-mb-debug.elf
endif

.PHONY: mb mb-debug

all: mb

mb: $(BIN)-mb.elf $(BIN)-mb.nc

mb-debug: $(BIN)-mb-debug.elf $(BIN)-mb-debug.nc

$(BIN)-mb.elf: $(BIN).cc $(SRC_FILES)
	$(MB_GCC) $(CFLAGS_MB) -o $@ $< $(LDFLAGS_MB)

$(BIN)-mb-debug.elf: $(BIN).cc $(SRC_FILES)
	$(MB_GCC) $(CFLAGS_MB) -DLAMBDA_DEBUG -o $@ $< $(LDFLAGS_MB)

$(BIN)-mb.nc: $(BIN)-mb.elf
	MAKEFLAGS=--no-print-directory $(SOC_HOME)/bin/mb-bin $< $(ARGS)

$(BIN)-mb-debug.nc: $(BIN)-mb-debug.elf
	MAKEFLAGS=--no-print-directory $(SOC_HOME)/bin/mb-bin $< $(ARGS)

else  # HAVE_MB

mb mb-debug:
	@echo "MicroBlaze target not supported, expected to find Starburst in $(SOC_HOME)"

endif # HAVE_MB

GARBAGE += $(call combine,$(BIN)-mb $(BIN)-mb-debug,$(EMPTY) .elf .nc .ash .bin .data .fun .ramfile .xmd .map)

ifeq ($(shell [ -e $(BIN).hs ] && echo yes),yes)
###########################################
## Haskell code for comparison

all: hs

hs: $(BIN)_hs

$(BIN)_hs: $(BIN).hs
	[ -z "$$LD_LIBRARY_PATH" ] || libs=-L$$LD_LIBRARY_PATH; \
	ghc --make -threaded $$libs -O2 -o $@ $<

hs-run: $(BIN)_hs
	$(PERF) ./$< $(ARGS) +RTS -N$(PROCS) $(OUTPUT_FILTER)

compare: bm-run hs-run

endif

GARBAGE += $(addprefix $(BIN),_hs .hi .o)


###########################################
## Distribute

VERSION = 0.0.1
DIST_NAME = lambda-$(VERSION)

COPYING:
	wget -O "$@" "http://www.gnu.org/licenses/gpl.txt"

DIST_FILES  = COPYING README Makefile lambda.cc include
DIST_FILES += $(wildcard examples/*/*.cc) $(wildcard examples/*/*.hs) $(wildcard examples/*/Makefile) examples/Makefile

dist: $(DIST_NAME).tgz

$(DIST_NAME):
	ln -s . $@

$(DIST_NAME).tgz: $(DIST_FILES) | $(DIST_NAME)
	tar -czf $@ $(addprefix $(DIST_NAME)/,$^)
	@[ ! -e ~/public_html ] || cp $@ ~/public_html
	

###########################################
## Misc

svn:
	@echo "$(strip $(GARBAGE))" | \
		$(SED) 's/ \+/\n/g' | \
		svn propset svn:ignore -F - .

info:
	@echo "$(V)='$($(V))'"

clean:
	rm -f $(GARBAGE)

